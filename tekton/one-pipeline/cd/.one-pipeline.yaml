# Documentation on available configuration
# https://pages.github.ibm.com/one-pipeline/docs/custom-scripts.html

version: '1'

setup:
  image: us.icr.io/otc-ops/otc-deploy:test
  image_pull_policy: Always
  script: |
    #!/usr/bin/env bash
    echo "setup"

deploy:
  #image: ibmcom/pipeline-base-image:2.6
  image: us.icr.io/opentoolchain/cd-deploy-base:deploy
  image_pull_policy: Always
  script: |
    #!/usr/bin/env bash

    # config
    export ENVIRONMENT=$(get_env region)
    export INVENTORY_URL=https://github.ibm.com/org-ids/inventory-umbrella-compliance
    export INVENTORY_BRANCH=$(get_env target-environment)
    export DOI_TOOLCHAIN_ID=$(get_env doi-toolchain-id)
    export IDS_JOB_ID=$PIPELINE_RUN_ID
    export IDS_USER=idsorg
    export REGISTRY_TOKEN_ID="10d3bc02-1aa0-5f94-a42a-92208f626af9"
    export OTC_REGISTRY=registry.ng.bluemix.net
    export PRUNE_CHART_REPO="true"
    export NAMESPACE=opentoolchain
    export WAIT_FOR_DEPLOY="true"
    export WAIT_FOR_DEPLOY_MAX="80"
    export EXCLUDED_FROM_STATUS_CHECK=$(get_env EXCLUDED_FROM_STATUS_CHECK "")
    export DRY_RUN=$(get_env DRY_RUN "")
    export DEPLOYMENT_SLACK_CHANNEL_ID=$(get_env DEPLOYMENT_SLACK_CHANNEL_ID)

    # secrets
    export IDS_TOKEN=$(get_env git-token)
    export IC_1308775_API_KEY=$(get_env IC_1308775_API_KEY "")
    export IC_1651315_API_KEY=$(get_env IC_1651315_API_KEY "")
    export IC_1416501_API_KEY=$(get_env IC_1416501_API_KEY "")
    export IC_1561947_API_KEY=$(get_env IC_1561947_API_KEY "")
    export IC_1562047_API_KEY=$(get_env IC_1562047_API_KEY "")
    export IC_2113612_API_KEY=$(get_env IC_2113612_API_KEY "")
    export NR_1783376_API_KEY=$(get_env NR_1783376_API_KEY)
    export OTC_REGISTRY_API_KEY=$(get_env IC_1416501_API_KEY "")
    export DEPLOYMENT_SLACK_TOKEN=$(get_env DEPLOYMENT_SLACK_TOKEN)

        set -e
        if [ "${SKIP}" == true ]; then
          echo "Skipping Deploy for $CLUSTER_NAME"
          exit 0
        fi
        cd "${SOURCE_DIRECTORY}"
        WORKDIR=${WORKDIR:-/work}
        VALUES_OPT=""

        if [ -z "$REGISTRY_API_KEY" ]; then
          REGISTRY_API_KEY=$API_KEY
        fi
        ibmcloud config --check-version=false
        ibmcloud plugin install -f container-service
        echo "Logging in to us.icr.io"
        ibmcloud login -a ${API} -r ${REGISTRY_REGION} --apikey ${REGISTRY_API_KEY}
        
        IMAGE_URL=${IMAGE_URL:-${REGISTRY_URL}/${REGISTRY_NAMESPACE}/${IMAGE_NAME}}
        COMPONENT_NAME=${COMPONENT_NAME:-${IMAGE_URL##*/}}

        if [[  -z "${APPLICATION_VERSION}" || "${APPLICATION_VERSION}" == "latest" ]]; then
          [ -r /workspace/appVersion ] && APPLICATION_VERSION=$( cat /workspace/appVersion )
          if [[  -z "${APPLICATION_VERSION}" || "${APPLICATION_VERSION}" == "latest" ]]; then
            ibmcloud cr images --restrict ${REGISTRY_NAMESPACE}/${COMPONENT_NAME} > _allImages
            APPLICATION_VERSION=$(cat _allImages | grep $(cat _allImages | grep latest | awk '{print $3}') | grep -v latest | awk '{print $2}')
          fi
        fi

        printf "Deploying release ${COMPONENT_NAME} into cluster ${CLUSTER_NAME},\nnamespace ${CLUSTER_NAMESPACE},\nwith image: ${IMAGE_URL}:${APPLICATION_VERSION}.\n"

        echo Current Directory: $(pwd)

        echo Logging into Deployment account
        ibmcloud login --apikey ${API_KEY} -r ${REGION}

        set +e
        function cluster_config() {
            # 1 - cluster name
            for iteration in {1..30}
            do
                echo "Running cluster config for cluster $1: $iteration / 30"
                ibmcloud ks cluster config --cluster $1
                if [[ $? -eq 0 ]]; then
                    return 0
                else
                    echo "Cluster config for $1 failed. Trying again..."
                    sleep 5
                fi
            done
            return 1
        }
        cluster_config ${CLUSTER_NAME}

        set -eo pipefail
        INGRESS_SUBDOMAIN=$(ibmcloud ks cluster get -s --cluster ${CLUSTER_NAME} | grep -i "Ingress subdomain:" | awk '{print $3;}')
        echo "INGRESS SUB DOMAIN: $INGRESS_SUBDOMAIN"
        if [[ ${INGRESS_SUBDOMAIN} == *,* ]];then
          INGRESS_SUBDOMAIN=$(echo "$INGRESS_SUBDOMAIN" | cut -d',' -f1)
          echo "INGRESS SUB DOMAIN: $INGRESS_SUBDOMAIN"
        fi

        INGRESS_SECRET=$(ibmcloud ks cluster get -s --cluster ${CLUSTER_NAME} | grep -i "Ingress secret:" | awk '{print $3;}')
        if [[ ${INGRESS_SECRET} == *,* ]];then
          INGRESS_SECRET=$(echo "$INGRESS_SECRET" | cut -d',' -f1)
          echo "INGRESS SECRET: $INGRESS_SECRET"
        fi

        CHART_PATH=$( ls -v charts/"${COMPONENT_NAME}"*.tgz |  tail -n 1 )
        echo Expanding "$CHART_PATH"
        if [ ! -e tmp/${COMPONENT_NAME} ]; then
          mkdir -p tmp ; cd tmp
          tar zxf ../$CHART_PATH
          cd ..
          # pick up the environment values fresh if available
          echo "component name=${COMPONENT_NAME}"
          echo "environment=${ENVIRONMENT}"
          echo "current dir=$(pwd)"
          [ -r "../devops-config/environments/${ENVIRONMENT}/values.yaml" ] && \
            cp ../devops-config/environments/${ENVIRONMENT}/values.yaml tmp/${COMPONENT_NAME}/charts/${ENVIRONMENT}
        fi

        set +e
        #helm version
        chartExists=$(helm list ${COMPONENT_NAME})
        if [ -z $chartExists ]; then
          deleted=$(helm list --all ${COMPONENT_NAME} | grep DELETED)
          echo "DELETED HELM: $deleted"
          if [ ! -z "$deleted" ]; then
            helm delete --purge ${COMPONENT_NAME}
          fi
          set -e
          echo "helm install --name ${COMPONENT_NAME} tmp/${COMPONENT_NAME} ${VALUES_OPT} --namespace ${CLUSTER_NAMESPACE} \
            --set tags.environment=false  --set ${ENVIRONMENT}.enabled=true  \
            --set global.ingressSubDomain=${INGRESS_SUBDOMAIN}"
          helm install --name ${COMPONENT_NAME} tmp/${COMPONENT_NAME} ${VALUES_OPT} --namespace ${CLUSTER_NAMESPACE} \
            --set tags.environment=false  --set ${ENVIRONMENT}.enabled=true  \
            --set global.ingressSubDomain=${INGRESS_SUBDOMAIN} --set global.ingressSecret=${INGRESS_SECRET}
        else
          set -e
          echo "helm upgrade --force ${COMPONENT_NAME} tmp/${COMPONENT_NAME} --install ${VALUES_OPT} --namespace ${CLUSTER_NAMESPACE} \
            --set tags.environment=false  --set ${ENVIRONMENT}.enabled=true \
            --set global.ingressSubDomain=${INGRESS_SUBDOMAIN}"
          helm upgrade --force ${COMPONENT_NAME} tmp/${COMPONENT_NAME} --install ${VALUES_OPT} --namespace ${CLUSTER_NAMESPACE} \
            --set tags.environment=false  --set ${ENVIRONMENT}.enabled=true \
            --set global.ingressSubDomain=${INGRESS_SUBDOMAIN} --set global.ingressSecret=${INGRESS_SECRET}
        fi
        set +e

        # save information for CR
        echo "Saving deploy info for CR"
        RUN=$( echo "${PIPELINE_RUN_URL}" \
              | cut -f7-9 -d/ | cut -f1 -d\? )
        RUN_ID=$( echo "$RUN" | cut -f3 -d/ )
        APP_VERSION=$( kubectl get -n${CLUSTER_NAMESPACE} deployment ${COMPONENT_NAME} -ojson \
          | jq -r '.spec.template.spec.containers[] | select(.name == "pipeline").image' \
          | cut -f2 -d: )
        echo "${COMPONENT_NAME},${APP_VERSION},${APPLICATION_VERSION},${CLUSTER_NAME},${PIPELINE_RUN_URL}"
        echo "${COMPONENT_NAME},${APP_VERSION},${APPLICATION_VERSION},${CLUSTER_NAME},${PIPELINE_RUN_URL}" >>"cr/$ENVIRONMENT/${RUN_ID}.csv"

        git config --global user.email "idsorg@us.ibm.com"
        git config --global user.name "IDS Organization"
        git config --global push.default matching
        git add -A "cr/$ENVIRONMENT"
        git commit -m "Adding deploy info for ${COMPONENT_NAME}-${CLUSTER_NAME}"

        n=0
        rc=0
        ORIG_DIR=$(pwd)
        until [ $n -ge 5 ]
        do
          git push
          rc=$?
          if [[ $rc == 0 ]]; then 
            break;
          fi
          n=$[$n+1]
          git pull
        done

acceptance-test:
  image: us.icr.io/otc-ops/otc-deploy:test
  image_pull_policy: Always
  script: |
    #!/usr/bin/env bash
    echo "tests"